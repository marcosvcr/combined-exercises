---
title: "Object oriented programming"
author: "Your Name"
date: "`r Sys.Date()`"
output:
  md_document:
    variant: markdown_github
---
```{r}

```

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Exercises for Object oriented programming


### Shapes

Let us imagine that we need to handle some geometric shapes for a program These could be circles, squares, triangles, etc. Properties we need to know about the shapes are their circumference and area. These properties can be calculated from properties of the shapes, but the calculations are different for each shape.

So for our shapes, we want (at least) an interface that gives us two functions: `circumference` and `area`. The default functions, where we have no additional information about an object aside from the fact that it is a shape, are meaningless so should raise an error (check the `stop` function for this), but each specialised shape should implement these two functions.

Implement this protocol/interface and the two functions for at least circles and rectangles; by all means, more shapes if you want to.

```{r}
### Classes
Circle <- function(x)
{

  me <- list(
    radius = x
  )

  ## Set the name for the class
  class(me) <- append(class(me),"Circle")
  return(me)
}

Square <- function(x)
{
  me <- list(
    size_Side = x
  )

  ## Set the name for the class
  class(me) <- append(class(me),"Square")
  return(me)



}



###polymorphism functions

circumference <- function(x)
{
  UseMethod("circumference", x)

}

circumference.default <- function(x)
{
  print("I do not know how to handle this object.")

}

circumference.Circle <- function(x)
{
  return(2*pi*x$radius)

}

circumference.Square <- function(x)
{
  print("Assuming a square inscribed on the circumference")
  print("using the Pythagorean theorem, that the length of a diagonal is sqrt(2)*side and so what you are calling the 'radius' is half the diagonal")
  r<- (sqrt(2)*x$size_Side)/2

  circun <- 2*pi*r
  print("the radius is")
  print(r)
  print("the circumference is")
  print(circun)
}


area <- function(x)
{
  UseMethod("area", x)

}

area.default <- function(x)
{
  print("I do not know how to handle this object.")

}


area.Circle <- function(x)
{
  return(pi*x$radius^2)

}



area.Square <- function(x)
{
  return(x$size_Side^2)

}



##### tests

b<- Square(2)
c <- Circle(7)

circumference(b)
circumference(c)
area(b)
area(c)
```
```{r}

```

### Polynomials

Write a class that lets you represent polynomial objects. An $n$-degree polynomial is on the form
$c_0 + c_1 * x + c_2 * x*x + \cdots + c_n * x * x * \cdots * x$
and can be represented by the $n+1$ coefficients $(c_0, c_1, \ldots, c_n)$. Write the interface such that you can evaluate polynomials in any point $x$, i.e. with a function `evaluate_polynomial(poly, x)` that gives you the value of the polynomial at the point `x`.

The function `uniroot` (built into R) lets you find the roots of a general function. Use it to write a function that finds the roots of your polynomials. This function works by numerically finding the points where the polynomial is zero. For lines and quadratic polynomials, though, there are analytical solutions. Write special cases for such polynomials such that calling the root finding function on the special cases exploits that solutions are known there.

```{r}
Polynome <- function(expression)
{

  thisEnv <- environment()

  me <- list(
    formula = function(x) eval(parse(text=expression)),
    thisEnv = thisEnv,

    ## The Methods for this class normally go here but are discussed
    ## below. A simple placeholder is here to give you a teaser....
    getEnv = function()
    {
      return(get("thisEnv",thisEnv))
    }


  )


  ## Set the name for the class
  class(me) <- append(class(me),"Polynome")
  return(me)
}

evaluate_polynomial <- function(obj, number)
{
  UseMethod("evaluate_polynomial", obj)

}

evaluate_polynomial.default <- function(obj, number)
{
  stop("I do not know how to handle this object.")

}

evaluate_polynomial.Polynome <- function(obj, number)
{
  return(obj$formula(number))

}



uniroot <- function(obj, lower=a, upper=b)
{

  UseMethod("uniroot", obj)

}

uniroot.Polynome <- function(obj, lower=a, upper=b)
{

  #bissec metthod

  if((upper-lower)<10^-4){
    raiz=lower
  }
  k=0

  while((upper-lower)>10^-4){
    M=obj$formula(lower)
    x=(lower+upper)/2
    if(M*obj$formula(x)>0){
      lower = x
    }else{
      upper=x
    }
    k=k+1
  }

  print("root is approximately: ")
  print(x)
  print("number of iterations")
  print(k)

}


### test

a <- Polynome("3*x")
b <- Polynome("4 + 3*x + 7*x^2 + 5*x^3")

evaluate_polynomial(a, 3)
evaluate_polynomial(b,2)
uniroot(b, lower=-7, upper=7)
uniroot(a, lower=-3, upper=3)

```


